# 项目 1: snek

欢迎来到 61C 的第一个项目！在这个项目中，你将通过创建一个可玩的贪吃蛇游戏来练习 C 语言编码。如果你对贪吃蛇不熟悉，[可以从这个链接试玩演示](https://www.xarg.org/project/html5-snake/)。

!!! info "注意"
    在开始此项目之前，请确保你已完成实验 0 的设置。

    实验 1-2 是项目 1 的必修课。建议使用第 2-4 讲和第 5 讲的内存管理/布局部分。建议参加讨论 1 和 2。

    我们将要求所有学生在提交项目 1 之前证明他们尝试过调试。如果没有尝试调试，或者很明显你不了解如何调试，我们将要求您完成实验 2 后再重新提交。

一些通用的测试和调试技巧可在编译、测试和调试以及常见错误页面中找到。

## 项目概述

### 贪吃蛇

贪吃蛇游戏可以用由字符组成的网格来表示。网格包含墙、果实和一条或多条蛇。下面是一个游戏示例: 

```
##############
#            #
#    dv      #
#     v   #  #
#     v   #  #
#   s >>D #  #
#   v     #  #
# *A<  *  #  #
#            #
##############
```

网格包含以下特殊字符: 

* `#` 表示墙。  
* `` ` ` ``（空格字符）表示空白空间。  
* `*` 表示果实。  
* `wasd` 表示蛇的尾部。  
* `^<v>` 表示蛇的身体。  
* `WASD` 表示蛇的头部。  
* `x` 表示已死亡的蛇头。

每个字符告诉你蛇当前移动的方向: 

* `w`、`W` 或 `^` 表示向上。  
* `a`、`A` 或 `<` 表示向左。  
* `s`、`S` 或 `v` 表示向下。  
* `d`、`D` 或 `>` 表示向右。

在每个时间步，蛇按以下规则移动: 

* 每条蛇沿头部指示的方向移动一步。  
* 如果头部撞到蛇身或墙壁，则该蛇死亡并停止移动，死亡时头部字符变为 `x`。  
* 如果头部移动到果实位置，蛇会吃掉果实，长度增加 1；每次吃掉果实后，会在棋盘上生成一个新的果实。

在上例中，经过一个时间步后，棋盘会变为: 

```
##############
#         *  #
#     s      #
#     v   #  #
#     v   #  #
#   s >>>D#  #
#   v     #  #
# A<<  *  #  #
#            #
##############
```

再经过一个时间步后，棋盘会变为: 

```
##############
#         *  #
#     s      #
#     v   #  #
#     v   #  #
#     >>>x#  #
#   s     #  #
#A<<<  *  #  #
#            #
##############
```

蛇的长度至少保证为三个单位。

### 给蛇编号

每条蛇根据其尾部在文件中出现的顺序进行编号（先按行从上到下，再按列从左到右）。例如，考虑下列包含四条蛇的棋盘: 

```
#############
#  s  d>>D  #
#  v   A<a  #
#  S    W   #
#       ^   #
#       w   #
#############
```

尾部为 `s` 的蛇是蛇 0，尾部为 `d` 的蛇是蛇 1，尾部为 `a` 的蛇是蛇 2，尾部为 `w` 的蛇是蛇 3。  
蛇在初始位置编号后，整个游戏过程中蛇的编号保持不变。

### 游戏棋盘

游戏棋盘是一个字符网格，不一定是矩形。下面是一个非矩形棋盘的示例: 

```
##############
#            #######
#####             ##
#   #             ##
#####             ######
#                 ##   #
#                 ######
#                 ##
#                  #
#      #####       #
########   #########
```

请注意: 

* 每行可以有不同数量的字符，但都会以 `#` 开头和结尾。  
* 棋盘是一个封闭空间，因此蛇无法无限制地向任意方向移动。

### game_t 结构体

贪吃蛇游戏在内存中存储为 `game_t` 结构体，该结构体在 `game.h` 中定义。结构体包含以下字段: 

* `unsigned int num_rows`: 游戏棋盘的行数。  
* `char** board`: 内存中的游戏棋盘。`board` 数组的每个元素都是指向字符数组的 `char*`，该数组包含一行棋盘。每行必须以换行符结尾，且是一个合法的字符串。  
* `unsigned int num_snakes`: 棋盘上的蛇的数量。  
* `snake_t* snakes`: `snake_t` 结构体数组。  

### snake_t 结构体

同样在 `game.h` 中定义，每个 `snake_t` 结构体包含以下字段: 

* `unsigned int tail_row`: 蛇尾所在行。  
* `unsigned int tail_col`: 蛇尾所在列。  
* `unsigned int head_row`: 蛇头所在行。  
* `unsigned int head_col`: 蛇头所在列。  
* `bool live`: 蛇是否存活，`true` 表示存活，`false` 表示已死亡。  

请不要修改提供的结构体定义。你只需要修改本项目中的 `game.c`、`snake.c` 和 `custom_tests.c` 文件。

## 编译、测试与调试

本项目提供了一个 `Makefile`，因为部分编译命令较为复杂，请不要自己调用 `gcc`！

项目包含两个可执行文件: 

* `unit-tests`: 包含针对任务 1 到 6 的所有单元测试。  
* `snake`: 包含完整的贪吃蛇游戏，并在任务 7 的集成测试中使用。  

要编译一个可执行文件，可以运行 `make executable-name`。 例如，要编译单元测试，请运行 `make unit-tests`。 然后就可以使用 `./unit-tests` 运行可执行文件，或在可执行文件上调用 `cgdb` 和 `valgrind`。 确保在修改代码后重新编译！

请注意，单元测试并不全面，通过测试并不能保证您的实现完全正确。 不过，它们应该有助于你开始调试。

## 任务 1: `create_default_game`

在 `game.c` 中实现 `create_default_game` 函数。该函数应在内存中创建一个默认的贪吃蛇游戏，使用以下起始游戏状态（可硬编码），并返回指向新创建的 `game_t` 结构的指针。

```
####################
#                  #
# d>D    *         #
#                  #
#                  #
#                  #
#                  #
#                  #
#                  #
#                  #
#                  #
#                  #
#                  #
#                  #
#                  #
#                  #
#                  #
####################
```

| `create_default_game`        |                          |                          |
|-----------------------------|--------------------------|--------------------------|
| **Arguments**               | None                     |                          |
| **Return values**           | `game_t *` | 指向新创建的 `game_t` 结构的指针 |

### 提示

* 棋盘有 18 行，每行 20 列。

* 果实位于第 2 行第 9 列（从 0 开始计数）。

* 蛇尾位于第 2 行第 2 列，蛇头位于第 2 行第 4 列。

* 应将新游戏存储在哪个内存区域（代码段、静态区、栈、堆）？

* `strcpy` 可能有所帮助。

* 每行棋盘都必须以换行符结尾，并且必须是有效的字符串。

### 测试与调试

* 提供了单元测试，可通过 `unit-tests` 可执行文件运行。

* 有关编译和调试，请参见“编译、测试与调试”。

## 任务 2: `free_game`

在 `game.c` 中实现 `free_game` 函数。此函数应释放给定游戏的所有内存，包括所有 `snake` 结构体和 `game->board` 的所有内容。

| `free_game`        |                                   |                                    |
|-----------------------------|--------------------------|------------------------------------|
| **Arguments**               | `game_t* game` | 指向要释放的 `game_t` 结构的指针 |
| **Return values**           | None         |                                                |

### 测试与调试

要测试是否正确释放游戏的内存，可运行 `make valgrind-test-free-game` 检查内存泄漏。如无泄漏，即通过本任务的单元测试。

## 任务 3: `print_board`

在 `game.c` 中实现 `print_board` 函数。此函数应将给定游戏棋盘的内容打印到指定的文件指针。

| `print_board`      |     |                                                                  |
|---------------|---------------|-----------------------------------------------------------------------------|
| **Arguments**    | `game_t* game`  | 指向要打印的 `game_t` 结构的指针            |
|              | `FILE* fp`      | 指向打印棋盘的文件对象的指针 |
| **Return values**| None            |                                                          |


### 提示

可使用 `fprintf` 函数将字符或字符串输出到指定文件指针。

### 测试与调试

本任务已提供单元测试，可通过 `unit-tests` 可执行文件运行。有关编译和调试的详细信息，请参阅“Compilation, Testing, and Debugging”部分。
  
如果函数执行成功（未发生段错误或崩溃）但输出不正确，打印的棋盘将保存在 `unit-test-out.snk` 文件中。正确打印的棋盘应与任务 1 中的默认棋盘一致。

## 任务 4: `update_game`

实现 `game.c` 中的 `update_game` 函数。该函数需要按照游戏规则让所有蛇前进一个时间步。

辅助函数不会被评分；本任务仅检查 `update_game` 是否实现正确。

### 任务 4.1: 辅助函数（`Helpers`）

以下为已提供但需你自行实现的辅助函数定义。它们与游戏棋盘或蛇本身无关，只接收单个字符并返回该字符的相关信息。

* `bool is_tail(char c)`: 若 `c` 属于蛇尾（字符集 `wasd`），返回 `true`；否则返回 `false`。  
* `bool is_head(char c)`: 若 `c` 属于蛇头（字符集 `WASDx`），返回 `true`；否则返回 `false`。  
* `bool is_snake(char c)`: 若 `c` 属于蛇的任意部分（字符集 `wasd^<v>WASDx`），返回 `true`；否则返回 `false`。  
* `char body_to_tail(char c)`: 将蛇身字符（`^<v>`）转换为对应的蛇尾字符（`wasd`）。若输入不是蛇身字符，则输出未定义。  
* `char head_to_body(char c)`: 将蛇头字符（`WASD`）转换为对应的蛇身字符（`^<v>`）。若输入不是蛇头字符，则输出未定义。  
* `unsigned int get_next_row(unsigned int cur_row, char c)`:   
  * 若 `c` 为 `v`、`s`、`S`，返回 `cur_row + 1`  
  * 若 `c` 为 `^`、`w`、`W`，返回 `cur_row - 1`  
  * 否则返回 `cur_row`  
* `unsigned int get_next_col(unsigned int cur_col, char c)`:   
  * 若 `c` 为 `>`、`d`、`D`，返回 `cur_col + 1`  
  * 若 `c` 为 `<`、`a`、`A`，返回 `cur_col - 1`  
  * 否则返回 `cur_col`

我们没有为这些辅助函数提供单元测试，因此您必须在 `custom_tests.c` 中编写自己的测试，以确保这些函数按预期工作。 请确保这些测试能全面测试您的辅助函数--我们的自动跟踪器会在有错误的实现上运行您的测试，以确保您的测试能捕捉到错误！

编写单元测试时，如果测试失败，测试函数应返回 `false`；如果测试通过，则返回 `true`。 您可以使用 `printf` 来打印调试信息。 `asserts.h` 中的一些 assert 辅助函数可能会有用。

一旦编写了自己的单元测试，就可以使用 `make custom-tests` 对其进行编译，从而生成可运行或调试的 `custom-tests` 可执行文件。

### 任务 4.2: `next_square`

在 `game.c` 中执行 `next_square` 辅助函数。该函数返回指定蛇移动到的单元格中的字符。 该函数不应修改内存中存储的任何游戏内容。

| `next_square`      |     |                                                                  |
|---------------|---------------|-----------------------------------------------------------------------------|
| **Arguments**    | `game_t* game`  | 指向要读取的 game_t 结构的指针            |
|              | `int snum`      | 所要读取的蛇的索引 |
| **Return values**| char            | 所读取的蛇移动到的单元格中的字符 |

举例来说，请看下面的棋盘: 

```
##############
#            #
#            #
#            #
#   d>D*     #
#            #
#       s    #
#       v    #
#       S    #
##############
```

假设 `game` 是指向 `game_t` 的指针，那么 `next_square(game,0)`应该返回 `*`，因为蛇 0 的头部正在移动到一个包含 `*` 的单元格中。 同样，对于蛇 1，`next_square(game, 1)` 应该返回 `#`。

您之前编写的辅助函数可能会对该函数（以及本任务的其他部分）有所帮助。 此外，还可以查看 `get_board_at` 和 `set_board_at`，它们是我们为您编写的辅助函数。

使用 `make unit-tests` 编译提供的单元测试。 您还可以使用 `p print_board(game,stdout)`在 `cgdb` 中调试时打印出整个棋盘。 

### 任务 4.3: `update_head`

在 `game.c` 中执行 `update_head` 函数，该函数将更新蛇的头部。

请记住，您需要更新游戏棋盘和 `snake_t` 结构中的蛇头。 在游戏棋盘上，在蛇移动的位置添加一个新的头部，并将旧头部从头部字符 (WASD) 改为身体字符 (^)。 在 `snake_t` 结构中，更新蛇头的行和列。

| `update_head`      |     |                                                                  |
|---------------|---------------|-----------------------------------------------------------------------------|
| **Arguments**    | `game_t* game`  | 指向要更新的 game_t 结构的指针            |
|              | `int snum`      | 所要更新的蛇的索引 |
| **Return values**| None            |                                                          |


举例来说，请看下面的棋盘：
```
##############
#   d>D      #
#        *   #
#        W   #
#        ^   #
#        ^   #
#        w   #
#            #
#            #
##############
```

假设 `game` 是指向此 `game_t` 的指针，那么 `update_head(game, 0)` 将移动蛇 0 的头部，而其他蛇的头部保持不变。 在蛇 0 对应的 `snake_t` 结构中，`head_col` 的值应该从 6 更新到 7，`head_row` 的值应该保持 1 不变：

```
##############
#   d>>D     #
#        *   #
#        W   #
#        ^   #
#        ^   #
#        w   #
#            #
#            #
##############
```

请注意，在移动头部时，该函数会忽略食物、墙壁和蛇体。

使用 `make unit-tests` 编译提供的单元测试。 您还可以使用 `p print_board(game,stdout)`在 `cgdb` 中调试时打印出整个棋盘。

### 任务 4.4: `update_tail`

在 `game.c` 中执行 `update_tail` 函数，该函数将更新蛇的尾巴。

请记住，您需要同时更新游戏棋盘和 `snake_t` 结构中的尾部。 在游戏棋盘上，将当前尾部空白，并将新尾部从正文字符 (`^<v>`) 改为尾部字符 (`wasd`)。 在 `snake_t` 结构中，更新尾部的行和列。

| `update_tail`      |     |                                                                  |
|---------------|---------------|-----------------------------------------------------------------------------|
| **Arguments**    | `game_t* game`  | 指向要更新的 game_t 结构的指针            |
|              | `int snum`      | 所要更新的蛇的索引 |
| **Return values**| None            |                                                          |

举例来说，请看下面的棋盘：
```
##############
#   d>D      #
#        *   #
#        W   #
#        ^   #
#        ^   #
#        w   #
#            #
#            #
##############
```

假设 game 是指向此 game_t 的指针，那么 update_tail(game, 1) 将移动蛇 1 的尾巴，其他蛇的尾巴保持不变。 在蛇 1 对应的 snake_t 结构中，tail_row 的值应该从 6 更新到 5，而 tail_col 的值应该保持 9 不变：

```
##############
#   d>D      #
#        *   #
#        W   #
#        ^   #
#        w   #
#            #
#            #
#            #
##############
```

使用 `make unit-tests` 编译提供的单元测试。 您还可以使用 `p print_board(game,stdout)`在 `cgdb` 中调试时打印出整个棋盘。

### 任务 4.5: `update_game`

使用您创建的辅助函数，在 game.c 中实现 update_game。

在此提醒，移动蛇的规则如下：

* 每条蛇向头部方向移动一步。

* 如果蛇头撞上蛇身或墙壁，蛇就会死亡并停止移动。 蛇死后，蛇头会被 "x "代替。

* 如果蛇头撞上了果实，蛇就会吃掉果实，并增长 1 个单位的长度。 (您可以通过更新蛇头而不更新蛇尾来实现长度增加 1 个单位)。 每吃一个水果，棋盘上就会生成一个新的水果。

`int (*add_food)(game_t* game)` 参数是一个函数指针，这意味着 `add_food` 是指向内存代码段的指针。 `add_food` 指向的代码是一个以 `game_t* game` 为参数并返回 `int` 的函数。 您可以用 `add_food(x)`调用这个函数，用您的参数替换 `x`，在棋盘上添加一个水果。

| `update_game`      |     |                                                                  |
|---------------|---------------|-----------------------------------------------------------------------------|
| **Arguments**    | `game_t* game`  | 指向要更新的 game_t 结构的指针            |
|              | `int (*add_food)(game_t* game)`      | 指向在棋盘上添加水果的函数指针 |
| **Return values**| None            |                                                          |

### 测试与调试

单元测试只针对 `update_game`，可通过 `unit-tests` 可执行文件运行。 有关编译和调试，请参阅编译、测试和调试。